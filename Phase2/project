#include "gtest/gtest.h"
#include "json.hpp"
#include "tinyxml2.h"
#include <boost/asio.hpp>
#include <boost/beast.hpp>
#include <boost/beast/websocket.hpp>
#include <atomic>
#include <unordered_set>
#include <mutex>
#include <thread>
#include <sys/sysinfo.h>

using json = nlohmann::json;
using namespace tinyxml2;
using namespace boost::asio;
using namespace boost::beast;
using namespace boost::beast::websocket;

// External function declarations
extern int getBootCount();
extern long getUptime();
extern void loadConfig();
extern void broadcastStats();
extern void handleClient(ip::tcp::socket socket);
extern std::atomic<int> boot_count;
extern int logging_interval;
extern std::unordered_set<std::shared_ptr<websocket::stream<ip::tcp::socket>>> clients;
extern std::mutex clients_mutex;

// **TEST 1: Boot Count Retrieval**
TEST(ServerTest, GetBootCount) {
    int count = getBootCount();
    EXPECT_GE(count, 0); // Should be non-negative
}

// **TEST 2: Uptime Retrieval**
TEST(ServerTest, GetUptime) {
    long uptime = getUptime();
    EXPECT_GT(uptime, 0); // Should be positive
}

// **TEST 3: Config Loading**
TEST(ServerTest, LoadConfig) {
    loadConfig();
    EXPECT_GT(logging_interval, 0); // Logging interval should be valid
}

// **TEST 4: Client Addition in WebSocket Server**
TEST(ServerTest, ClientAddition) {
    std::lock_guard<std::mutex> lock(clients_mutex);
    auto client_before = clients.size();

    auto dummy_socket = std::make_shared<websocket::stream<ip::tcp::socket>>(boost::asio::io_context());
    clients.insert(dummy_socket);
    
    auto client_after = clients.size();
    EXPECT_EQ(client_after, client_before + 1); // One client should be added
}

// **TEST 5: WebSocket Message Format**
TEST(ServerTest, WebSocketMessageFormat) {
    json stats;
    stats["boot_count"] = boot_count.load();
    stats["uptime"] = getUptime();

    std::string expected_json = stats.dump();
    EXPECT_FALSE(expected_json.empty()); // JSON should not be empty
}

// **TEST 6: Boot Count and Uptime JSON Format**
TEST(ServerTest, JsonResponseFormat) {
    json response_json;
    response_json["boot_count"] = boot_count.load();
    response_json["uptime"] = getUptime();

    EXPECT_TRUE(response_json.contains("boot_count"));
    EXPECT_TRUE(response_json.contains("uptime"));
}

// **TEST 7: WebSocket Broadcast Mechanism**
TEST(ServerTest, WebSocketBroadcast) {
    std::thread broadcaster(broadcastStats);
    std::this_thread::sleep_for(std::chrono::seconds(2)); // Allow some time for broadcast
    broadcaster.detach();
    EXPECT_TRUE(true); // If the function runs without crash, test is successful
}

// **TEST 8: Ensure No Duplicate Client Entry**
TEST(ServerTest, DuplicateClientEntry) {
    std::lock_guard<std::mutex> lock(clients_mutex);
    auto client = std::make_shared<websocket::stream<ip::tcp::socket>>(boost::asio::io_context());

    clients.insert(client);
    size_t before = clients.size();
    clients.insert(client); // Try adding the same client

    EXPECT_EQ(before, clients.size()); // Set should not allow duplicates
}

// **MAIN FUNCTION TO RUN ALL TEST CASES**
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}