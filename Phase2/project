void handleClient(ip::tcp::socket socket) {
    try {
        auto ws = std::make_shared<websocket::stream<ip::tcp::socket>>(std::move(socket));
        ws->accept();

        {
            std::lock_guard<std::mutex> lock(clients_mutex);
            clients.insert(ws);
        }

        // âœ… Immediately send first stat after client connects
        json firstStat;
        firstStat["boot_count"] = boot_count.load();
        firstStat["uptime"] = getUptime();
        ws->write(net::buffer(firstStat.dump()));  // ðŸ”¥ First stat sent instantly

        std::cout << "[New Client] First stat sent: " << firstStat.dump() << "\n";

        boost::beast::flat_buffer buffer;
        while (true) {
            boost::system::error_code ec;
            ws->read(buffer, ec);
            if (ec == websocket::error::closed) {
                break;
            }
        }

        std::lock_guard<std::mutex> lock(clients_mutex);
        clients.erase(ws);
    } catch (...) {
        std::cerr << "Client disconnected.\n";
    }
}






void connectToServer() {
    io_context ioc;
    ip::tcp::resolver resolver(ioc);
    auto endpoints = resolver.resolve("localhost", "8080");

    websocket::stream<ip::tcp::socket> ws(ioc);
    boost::asio::connect(ws.next_layer(), endpoints);
    ws.handshake("localhost", "/");

    std::cout << "Connected to server, receiving stats...\n";

    while (true) {
        boost::beast::flat_buffer buffer;
        boost::system::error_code ec;
        ws.read(buffer, ec);

        if (ec) {
            std::cerr << "Error receiving stats: " << ec.message() << "\n";
            break;
        }

        std::string data = boost::beast::buffers_to_string(buffer.data());
        json stats = json::parse(data);
        saveStatsToCSV(stats["boot_count"], stats["uptime"]);

        std::cout << "[Received Stats] Boot Count: " << stats["boot_count"]
                  << ", Uptime: " << stats["uptime"] << " seconds\n";
    }
}