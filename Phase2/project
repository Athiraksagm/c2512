// Test if a client can successfully connect and disconnect
TEST(ServerTest, ClientConnection) {
    io_context ioc;
    ip::tcp::acceptor acceptor(ioc, ip::tcp::endpoint(ip::tcp::v4(), 9000));
    ip::tcp::socket socket(ioc);
    
    // Simulate a client connection
    std::thread server_thread([&]() {
        ip::tcp::socket server_socket(ioc);
        acceptor.accept(server_socket);
        handleClient(std::move(server_socket));
    });

    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Give server some time to start

    // Connect the client
    socket.connect(acceptor.local_endpoint());
    EXPECT_TRUE(socket.is_open());

    // Disconnect the client
    socket.close();
    EXPECT_FALSE(socket.is_open());

    server_thread.join();
}

// Test adding a client to the active list
TEST(ServerTest, AddClientToActiveList) {
    io_context ioc;
    ip::tcp::socket socket(ioc);
    
    auto ws = std::make_shared<websocket::stream<ip::tcp::socket>>(std::move(socket));
    
    {
        std::lock_guard<std::mutex> lock(clients_mutex);
        clients.insert(ws);
    }

    // Ensure the client was added
    EXPECT_EQ(clients.size(), 1);
}

// Test removing a client from the active list
TEST(ServerTest, RemoveClientFromActiveList) {
    io_context ioc;
    ip::tcp::socket socket(ioc);
    
    auto ws = std::make_shared<websocket::stream<ip::tcp::socket>>(std::move(socket));
    
    {
        std::lock_guard<std::mutex> lock(clients_mutex);
        clients.insert(ws);
    }

    // Ensure the client was added
    EXPECT_EQ(clients.size(), 1);

    // Now remove the client
    {
        std::lock_guard<std::mutex> lock(clients_mutex);
        clients.erase(ws);
    }

    // Ensure the client was removed
    EXPECT_EQ(clients.size(), 0);
}

// Test client sending "REQUEST_STATS" and receiving a response
TEST(ServerTest, HandleClientRequestStats) {
    io_context ioc;
    ip::tcp::socket client_socket(ioc);
    ip::tcp::acceptor acceptor(ioc, ip::tcp::endpoint(ip::tcp::v4(), 9000));

    std::thread server_thread([&]() {
        ip::tcp::socket server_socket(ioc);
        acceptor.accept(server_socket);
        handleClient(std::move(server_socket));
    });

    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Allow server to start

    // Connect the client
    client_socket.connect(acceptor.local_endpoint());
    EXPECT_TRUE(client_socket.is_open());

    websocket::stream<ip::tcp::socket> ws(std::move(client_socket));
    ws.handshake("localhost", "/");
    
    // Send REQUEST_STATS message
    ws.write(net::buffer(std::string("REQUEST_STATS")));

    boost::beast::flat_buffer buffer;
    boost::system::error_code ec;

    // Receive response
    ws.read(buffer, ec);
    EXPECT_FALSE(ec) << "Error reading response: " << ec.message();

    std::string response = boost::beast::buffers_to_string(buffer.data());
    json stats = json::parse(response);

    // Ensure response contains boot_count and uptime
    EXPECT_TRUE(stats.contains("boot_count"));
    EXPECT_TRUE(stats.contains("uptime"));

    ws.close(websocket::close_code::normal);

    server_thread.join();
}