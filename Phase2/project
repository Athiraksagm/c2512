TEST(ServerTest, RemoveDisconnectedClient) {
    io_context ioc;
    ip::tcp::socket socket(ioc);
    auto ws = std::make_shared<websocket::stream<ip::tcp::socket>>(std::move(socket));

    {
        std::lock_guard<std::mutex> lock(clients_mutex);
        clients.insert(ws);
    }

    // Simulate client disconnect
    {
        std::lock_guard<std::mutex> lock(clients_mutex);
        clients.erase(ws);
    }

    EXPECT_EQ(clients.size(), 0) << "Disconnected clients should be removed.";
}





TEST(SystemStatsTest, LoadConfig_MissingLoggingInterval) {
    std::ofstream configFile("../source/config.xml");
    configFile << "<config>\n"
               << "    <!-- Missing logging_interval -->\n"
               << "</config>";
    configFile.close();

    loadConfig();
    EXPECT_EQ(logging_interval, 10) << "Default logging interval should be used when missing.";
}




TEST(SystemStatsTest, GetBootCount_Valid) {
    int boot_count = getBootCount();
    EXPECT_GE(boot_count, 0) << "Boot count should be a non-negative integer.";
}

TEST(SystemStatsTest, GetBootCount_Failure) {
    // Simulate failure by redirecting `popen()` to an invalid command
    FILE* pipe = popen("invalid_command", "r");
    if (!pipe) {
        int result = getBootCount();
        EXPECT_EQ(result, -1) << "Should return -1 on failure to execute command.";
    }
}





TEST(SystemStatsTest, GetUptime_Valid) {
    long uptime = getUptime();
    EXPECT_GT(uptime, 0) << "Uptime should be a positive value.";
}

TEST(SystemStatsTest, GetUptime_Failure) {
    // Simulate failure by modifying `sysinfo` response (Requires mocking)
    struct sysinfo info;
    memset(&info, 0, sizeof(info));  // Set uptime to 0 artificially

    long result = getUptime();
    EXPECT_NE(result, -1) << "Should return -1 if sysinfo() fails.";
}