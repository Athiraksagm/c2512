#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "../include/server.h"
#include <thread>
#include <fstream>
#include <sys/sysinfo.h>
#include <atomic>

using ::testing::_;
using ::testing::Return;
using ::testing::Invoke;
using ::testing::NiceMock;

extern std::atomic<int> boot_count;
extern int logging_interval;

// Mock for WebSocket Stream
class MockWebSocket {
public:
    MOCK_METHOD(void, write, (const boost::asio::const_buffer&, boost::system::error_code&), ());
    MOCK_METHOD(void, read, (boost::beast::flat_buffer&, boost::system::error_code&), ());
};

// ** Test getBootCount() **
TEST(SystemStatsTest, GetBootCountReturnsValidCount) {
    int count = getBootCount();
    ASSERT_GE(count, 0);  // Boot count should be non-negative
}

// ** Test getUptime() **
TEST(SystemStatsTest, GetUptimeReturnsValidTime) {
    long uptime = getUptime();
    ASSERT_GT(uptime, 0);  // Uptime should always be greater than zero
}

// ** Test loadConfig() **
TEST(SystemStatsTest, LoadConfigUpdatesLoggingInterval) {
    std::ofstream configFile("../config.xml");
    configFile << "<config><logging_interval>5</logging_interval></config>";
    configFile.close();

    loadConfig();
    ASSERT_EQ(logging_interval, 5);  // Check if interval was updated
}

// ** Test broadcastStats() Loop **
TEST(SystemStatsTest, BroadcastStatsSendsCorrectData) {
    logging_interval = 1;
    boot_count.store(5);

    std::string expected_message = R"({"boot_count":5,"uptime":)";
    
    MockWebSocket mockWs;
    EXPECT_CALL(mockWs, write(_, _))
        .WillRepeatedly(Invoke([&](const boost::asio::const_buffer& buffer, boost::system::error_code& ec) {
            std::string message(static_cast<const char*>(buffer.data()), buffer.size());
            ASSERT_TRUE(message.find(expected_message) != std::string::npos);
        }));

    std::thread broadcastThread(broadcastStats);
    std::this_thread::sleep_for(std::chrono::seconds(2)); // Let it run twice
    broadcastThread.detach();
}

// ** Test handleClient() with Mock WebSocket **
TEST(SystemStatsTest, HandleClientSendsInitialStats) {
    std::string expected_message = R"({"boot_count":)";
    
    MockWebSocket mockWs;
    EXPECT_CALL(mockWs, write(_, _))
        .WillOnce(Invoke([&](const boost::asio::const_buffer& buffer, boost::system::error_code& ec) {
            std::string message(static_cast<const char*>(buffer.data()), buffer.size());
            ASSERT_TRUE(message.find(expected_message) != std::string::npos);
        }));

    std::thread clientThread([&]() {
        boost::asio::io_context ioc;
        boost::asio::ip::tcp::socket socket(ioc);
        handleClient(std::move(socket));
    });

    clientThread.detach();
}

// ** Test Server Start and Accept Loop **
TEST(SystemStatsTest, ServerStartsAndAcceptsConnections) {
    std::thread serverThread([]() {
        char* argv[] = { (char*)"server", (char*)"9001" };
        main(2, argv);
    });

    std::this_thread::sleep_for(std::chrono::seconds(1));  // Allow server to initialize
    serverThread.detach();
}