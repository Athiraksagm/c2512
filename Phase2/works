#include "StatisticsTracker.h"
#include <fstream>
#include <iostream>
#include <chrono>
#include <thread>

StatisticsTracker::StatisticsTracker() : bootCount(0), totalUptime(0) {
    update();
}

void StatisticsTracker::update() {
    std::lock_guard<std::mutex> lock(mtx);
    bootCount++;
    totalUptime += 60; // Simulating uptime increment
}

int StatisticsTracker::getBootCount() {
    std::lock_guard<std::mutex> lock(mtx);
    return bootCount;
}

long StatisticsTracker::getTotalUptime() {
    std::lock_guard<std::mutex> lock(mtx);
    return totalUptime;
}



#ifndef REST_API_HANDLER_H
#define REST_API_HANDLER_H

#include "StatisticsTracker.h"
#include <httplib.h>

class RestApiHandler {
private:
    StatisticsTracker& tracker;
    httplib::Server svr;

public:
    RestApiHandler(StatisticsTracker& tracker);
    void startServer();
};

#endif



#include "RestApiHandler.h"
#include <nlohmann/json.hpp>
#include <iostream>

RestApiHandler::RestApiHandler(StatisticsTracker& tracker) : tracker(tracker) {}

void RestApiHandler::startServer() {
    svr.Get("/stats", [this](const httplib::Request&, httplib::Response& res) {
        nlohmann::json response;
        response["boot_count"] = tracker.getBootCount();
        response["total_uptime"] = tracker.getTotalUptime();
        res.set_content(response.dump(), "application/json");
    });

    std::cout << "Server running on port 8080..." << std::endl;
    svr.listen("0.0.0.0", 8080);
}


#ifndef CONFIG_LOADER_H
#define CONFIG_LOADER_H

#include <string>

class ConfigLoader {
public:
    int getUpdateInterval();
};

#endif



#include "ConfigLoader.h"
#include <pugixml.hpp>
#include <iostream>

int ConfigLoader::getUpdateInterval() {
    pugi::xml_document doc;
    if (!doc.load_file("config.xml")) {
        std::cerr << "Failed to load config.xml\n";
        return 10;
    }
    return doc.child("config").child("updateInterval").text().as_int();
}


#ifndef PERIODIC_UPDATER_H
#define PERIODIC_UPDATER_H

#include "StatisticsTracker.h"
#include "ConfigLoader.h"
#include <thread>
#include <chrono>

class PeriodicUpdater {
private:
    StatisticsTracker& tracker;
    ConfigLoader& config;

public:
    PeriodicUpdater(StatisticsTracker& tracker, ConfigLoader& config);
    void run();
};

#endif



#include "PeriodicUpdater.h"

PeriodicUpdater::PeriodicUpdater(StatisticsTracker& tracker, ConfigLoader& config)
    : tracker(tracker), config(config) {}

void PeriodicUpdater::run() {
    while (true) {
        std::this_thread::sleep_for(std::chrono::seconds(config.getUpdateInterval()));
        tracker.update();
    }
}











Give me the c++ code for my project,the requirements are as follows.

1.System Stat Logging Microservice
2.1 Introduction
The System Stat Logging Microservice tracks system boot count and total uptime over its lifetime. The server periodically sends system statistics to clients at a configurable interval.
2.2 Functional Requirements
2.2.1 Server Application
1.	Monitor the number of boots and total uptime of the system.
2.	Configurable interval for sending statistics (defined in an XML file).
3.	Client shall request the server using REST API.
4.	Respond to client requests with current statistics in JSON format.
5.	Send periodic updates to clients based on the configured interval.
6.	Handle multiple client requests concurrently.
2.2.2 Client Application
1.	Request system statistics from the server.
2.	Receive and parse JSON responses.
3.	Store system statistics in a CSV file when enabled via a command-line option.
4.	The CSV file should include date, time, number of boots, and total uptime with proper heading.
2.3 Non-Functional Requirements
1.	Implemented in C++14 or above.
2.	Separate projects for server and client, compiled using CMake.
3.	Unit tests (UT) for the server using GTest.
4.	Multi-threaded architecture to handle multiple client requests simultaneously.
________________________________________
3. Common Considerations
1.	Communication between server and client will use JSON format.
2.	Server applications will use multi-threading to handle concurrent client requests.
3.	Configuration settings (thresholds and intervals) will be stored in XML files.
4.	The system should be robust, ensuring minimal resource usage and optimized performance.
5.	Error handling should be implemented to manage connection failures, invalid requests, and unexpected conditions.


2.The structure of my project should look like this.
SystemStatLoggingMicroservice/
├── server/
│   ├── CMakeLists.txt
│   ├── main.cpp
│   ├── StatisticsTracker.h
│   ├── StatisticsTracker.cpp
│   ├── RestApiHandler.h
│   ├── RestApiHandler.cpp
│   ├── ConfigLoader.h
│   ├── ConfigLoader.cpp
│   └── PeriodicUpdater.h
│   └── PeriodicUpdater.cpp
├── client/
│   ├── CMakeLists.txt
│   ├── main.cpp
│   ├── ApiClient.h
│   ├── ApiClient.cpp
│   ├── JsonParser.h
│   ├── JsonParser.cpp
│   └── CsvLogger.h
│   └── CsvLogger.cpp
└── tests/
    ├── CMakeLists.txt
    └── ServerTests.cpp
