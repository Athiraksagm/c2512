#include <iostream>
#include <fstream>
#include <string>
#include <Poco/Net/HTTPServer.h>
#include <Poco/Net/HTTPRequestHandlerFactory.h>
#include <Poco/Net/HTTPServerParams.h>
#include <Poco/Thread.h>
#include <Poco/Net/HTTPServerRequest.h>
#include <Poco/Net/HTTPServerResponse.h>
#include <sys/sysinfo.h>
#include <ctime>

const std::string BOOT_COUNT_FILE = "boot_count.txt";

// Function to get system boot count
int getBootCount() {
    std::ifstream file(BOOT_COUNT_FILE);
    int bootCount = 0;
    
    if (file.is_open()) {
        file >> bootCount; // Read current boot count from the file
        file.close();
    }
    
    return bootCount;
}

// Function to update boot count
void updateBootCount(int bootCount) {
    std::ofstream file(BOOT_COUNT_FILE);
    if (file.is_open()) {
        file << bootCount; // Write the updated boot count to the file
        file.close();
    }
}

// Function to get system uptime
long getUptime() {
    struct sysinfo info;
    if (sysinfo(&info) == 0) {
        return info.uptime;
    }
    return 0;
}

// Request handler for the server
class RequestHandler : public Poco::Net::HTTPRequestHandler {
public:
    void handleRequest(Poco::Net::HTTPServerRequest& request, Poco::Net::HTTPServerResponse& response) override {
        response.setContentType("application/json");
        std::ostream& ostr = response.send();
        
        int bootCount = getBootCount();
        long uptime = getUptime();

        // Create JSON response
        ostr << "{"
             << "\"boot_count\": " << bootCount << ", "
             << "\"uptime\": " << uptime
             << "}";
    }
};

// Request handler factory
class RequestHandlerFactory : public Poco::Net::HTTPRequestHandlerFactory {
public:
    Poco::Net::HTTPRequestHandler* createRequestHandler(const Poco::Net::HTTPServerRequest& request) override {
        return new RequestHandler();
    }
};

int main() {
    // Step 1: Check for boot count file and update boot count
    int bootCount = getBootCount();
    bootCount++;
    updateBootCount(bootCount);

    std::cout << "=============================" << std::endl;
    std::cout << " SYSTEM STAT LOGGING SERVER " << std::endl;
    std::cout << "=============================" << std::endl;
    std::cout << "Boot Count: " << bootCount << std::endl;
    
    // Step 2: Start the HTTP server
    Poco::Net::HTTPServerParams* pParams = new Poco::Net::HTTPServerParams;
    Poco::Net::HTTPServer srv(new RequestHandlerFactory(), Poco::Net::ServerSocket(8080), pParams);
    srv.start();
    
    std::cout << "Server running at http://localhost:8080..." << std::endl;
    std::cout << "Waiting for client requests..." << std::endl;
    
    // Keep the server running
    Poco::Thread::sleep(Poco::Timespan::SECONDS * 3600);
    
    return 0;
}






#include <iostream>
#include <curl/curl.h>

size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
    ((std::string*)userp)->append((char*)contents, size * nmemb);
    return size * nmemb;
}

int main() {
    CURL* curl;
    CURLcode res;
    std::string readBuffer;

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();

    if(curl) {
        // Set the URL of the server
        curl_easy_setopt(curl, CURLOPT_URL, "http://localhost:8080");

        // Set the write callback to capture the response
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);

        // Perform the request
        res = curl_easy_perform(curl);

        // Check for errors
        if(res != CURLE_OK) {
            std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << std::endl;
        } else {
            std::cout << "Response from server: " << readBuffer << std::endl;
        }

        // Clean up
        curl_easy_cleanup(curl);
    }

    curl_global_cleanup();
    return 0;
}