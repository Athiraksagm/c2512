#include "gtest/gtest.h"
#include "server.h"
#include "json.hpp"
#include <fstream>
#include <iostream>
#include <atomic>
#include <sys/sysinfo.h>
#include <unistd.h>
#include <sstream>
#include <array>
#include <memory>
#include <boost/asio.hpp>
#include <boost/beast.hpp>
#include <tinyxml2.h>

using json = nlohmann::json;
//using namespace tinyxml2;
using namespace boost::asio;
using namespace boost::beast;
using namespace boost::asio::ip;

// Global variables from server.cpp
std::atomic<int> boot_count(0);
//extern int logging_interval;


// **Mocked function for getBootCount()**
int mock_getBootCount(std::string command_output = "5\n") {
    try {
        return std::stoi(command_output);
    } catch (...) {
        return -1;  // Simulate error case
    }
}

// **Mocked function for getUptime()**
long mock_getUptime(long fake_uptime = 3600) {
    return fake_uptime;  // Returns a predefined uptime
}

// **Mock sysinfo function**
struct sysinfo mock_sysinfo;
int sysinfo(struct sysinfo *info) {
    if (info) {
        info->uptime = 3600;  // Mock uptime (1 hour)
        return 0;  // Mock success
    }
    return -1;  // Simulate failure
}

// // **Mock function for loading config**
// void mock_loadConfig(std::string filename = "mock_config.xml") {
//     XMLDocument doc;
//     doc.LoadFile(filename.c_str());
//     XMLElement *root = doc.FirstChildElement("config");
//     if (root) {
//         XMLElement *intervalElement = root->FirstChildElement("logging_interval");
//         if (intervalElement) {
//             logging_interval = std::stoi(intervalElement->GetText());
//         }
//     }
// }

// **TEST 1: Boot count retrieval (Normal Case)**
TEST(SystemStatsTest, BootCountRetrieval) {
    boot_count.store(mock_getBootCount("5\n"));
    EXPECT_EQ(boot_count.load(), 5);
}

// **TEST 2: Boot count retrieval (Error Case)**
TEST(SystemStatsTest, BootCountRetrievalError) {
    boot_count.store(mock_getBootCount("invalid_data\n"));
    EXPECT_EQ(boot_count.load(), -1);
}

// **TEST 3: Uptime retrieval (Normal Case)**
TEST(SystemStatsTest, UptimeRetrieval) {
    EXPECT_EQ(mock_getUptime(7200), 7200);
}

// **TEST 4: Uptime retrieval (Error Case)**
TEST(SystemStatsTest, UptimeRetrievalError) {
    struct sysinfo info;
    int result = sysinfo(nullptr);  // Simulate sysinfo failure
    EXPECT_EQ(result, -1);
}

// // **TEST 5: loadConfig() updates logging interval**
// TEST(SystemStatsTest, LoadConfig) {
//     std::ofstream configFile("mock_config.xml");
//     configFile << "<config><logging_interval>15</logging_interval></config>";
//     configFile.close();

//     logging_interval = 10;  // Reset before test
//     mock_loadConfig("mock_config.xml");
//     EXPECT_EQ(logging_interval, 15);
// }

// **TEST 6: broadcastStats() runs without crash**
TEST(SystemStatsTest, BroadcastStatsRuns) {
    std::thread broadcastThread([]() {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    });
    broadcastThread.join();
    EXPECT_TRUE(true);  // If no crash, test passes
}

// **TEST 7: handleClient() initializes correctly**
// TEST(SystemStatsTest, HandleClientInitializes) {
//     io_context ioc;
//     tcp::socket socket(ioc);
//     EXPECT_NO_THROW(handleClient(std::move(socket)));
// }

// **TEST 8: JSON Response Format**
TEST(SystemStatsTest, JsonResponseFormat) {
    json response_json;
    boot_count.store(5);
    response_json["boot_count"] = boot_count.load();
    response_json["uptime"] = mock_getUptime();

    std::string expected_json = "{\"boot_count\":5,\"uptime\":3600}";
    EXPECT_EQ(response_json.dump(), expected_json);
}

// **MAIN FUNCTION**
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
