1. config/config.xml (Configuration File)
This file contains the configuration values for the system, such as the interval for sending updates.

xml
Copy
Edit
<?xml version="1.0" encoding="UTF-8"?>
<config>
    <!-- Interval in seconds for periodic updates -->
    <interval>10</interval>
</config>
2. Server Code (src/server.cpp)
The server will:

Read the interval from the config.xml file.
Monitor system stats (e.g., uptime and boot count).
Respond to client requests with these stats.
Send periodic updates at the configured interval.
cpp
Copy
Edit
#include "httplib.h"
#include "json.hpp"
#include <iostream>
#include <thread>
#include <chrono>
#include <atomic>
#include <sys/sysinfo.h>
#include <unistd.h>
#include <fstream>
#include "tinyxml2.h"

using json = nlohmann::json;

// Global variables to track the stats
std::atomic<int> boot_count(0);
std::atomic<long> total_uptime(0);

// Function to read the update interval from the config file
int getUpdateIntervalFromConfig() {
    tinyxml2::XMLDocument doc;
    doc.LoadFile("config/config.xml");  // Load the XML configuration file

    tinyxml2::XMLElement* root = doc.FirstChildElement("config");
    if (root) {
        tinyxml2::XMLElement* intervalElement = root->FirstChildElement("interval");
        if (intervalElement) {
            return intervalElement->IntText();  // Get the interval value (in seconds)
        } else {
            std::cerr << "Error: Interval not found in config.xml" << std::endl;
            return 10;  // Default value if not found
        }
    } else {
        std::cerr << "Error: Could not find the config root element" << std::endl;
        return 10;  // Default value if file is not loaded properly
    }
}

// Function to get the system's uptime and boot count
void updateSystemStats() {
    struct sysinfo info;
    if (sysinfo(&info) == 0) {
        total_uptime.store(info.uptime);  // total uptime in seconds
    }
    // In this example, we don't have a direct boot count, so we'll simulate it.
    boot_count.store(boot_count.load() + 1);
}

// Server handler to send stats to the client
void handleClientRequest(const httplib::Request &req, httplib::Response &res) {
    json response_json;
    response_json["boots"] = boot_count.load();
    response_json["uptime"] = total_uptime.load();

    res.set_content(response_json.dump(), "application/json");
}

// Function to send periodic updates based on the interval read from config.xml
void sendPeriodicUpdates(httplib::Server &server) {
    int interval = getUpdateIntervalFromConfig();  // Get interval from XML

    while (true) {
        std::this_thread::sleep_for(std::chrono::seconds(interval));  // Wait for the interval duration
        updateSystemStats();  // Update system stats

        std::cout << "Sending periodic updates to clients..." << std::endl;
        // Here, you can implement logic to notify clients if needed
    }
}

int main() {
    httplib::Server server;

    // Define the route for client requests
    server.Get("/stats", handleClientRequest);

    // Run the server in a separate thread to handle multiple requests concurrently
    std::thread update_thread(sendPeriodicUpdates, std::ref(server));

    std::cout << "Server running at http://localhost:8080..." << std::endl;
    server.listen("localhost", 8080);

    update_thread.join();  // Wait for the update thread to finish (it won't unless terminated)
}
3. Client Code (src/client.cpp)
The client will:

Request system stats from the server.
Parse the JSON response.
Optionally store the stats in a CSV file.
cpp
Copy
Edit
#include "httplib.h"
#include "json.hpp"
#include <iostream>
#include <fstream>
#include <ctime>

using json = nlohmann::json;

void saveStatsToCSV(const json &stats) {
    std::ofstream file("system_stats.csv", std::ios::app);
    if (!file.is_open()) {
        std::cerr << "Failed to open CSV file!" << std::endl;
        return;
    }

    // Write the header if the file is empty
    file.seekp(0, std::ios::end);
    if (file.tellp() == 0) {
        file << "Date,Time,Boot Count,Uptime (seconds)\n";
    }

    // Get the current time
    std::time_t now = std::time(nullptr);
    std::tm *local_time = std::localtime(&now);
    
    file << 1900 + local_time->tm_year << "-"
         << 1 + local_time->tm_mon << "-"
         << local_time->tm_mday << ","
         << local_time->tm_hour << ":"
         << local_time->tm_min << ":"
         << local_time->tm_sec << ","
         << stats["boots"].get<int>() << ","
         << stats["uptime"].get<long>() << "\n";

    file.close();
}

int main() {
    httplib::Client client("http://localhost:8080");

    // Send a GET request to fetch system stats
    auto res = client.Get("/stats");

    if (res && res->status == 200) {
        json stats = json::parse(res->body);
        std::cout << "Received stats:\n";
        std::cout << "Boot Count: " << stats["boots"] << "\n";
        std::cout << "Uptime: " << stats["uptime"] << " seconds\n";

        // Optionally save to CSV
        saveStatsToCSV(stats);
    } else {
        std::cerr << "Error: Unable to fetch stats from server." << std::endl;
    }

    return 0;
}
Key Points:
Server: Periodically updates system stats and sends them to clients on request. It reads the interval from the config.xml file.
Client: Sends GET requests to the server, receives stats, and optionally stores them in a CSV file.
Next Steps:
