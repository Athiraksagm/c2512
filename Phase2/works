#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "../include/server.h"
#include <fstream>
#include <sys/sysinfo.h>
#include <atomic>

using ::testing::_;
using ::testing::Return;
using ::testing::Invoke;
using ::testing::NiceMock;

extern std::atomic<int> boot_count;
extern int logging_interval;

// ** Test getBootCount() **
TEST(SystemStatsTest, GetBootCountReturnsValidCount) {
    int count = getBootCount();
    ASSERT_GE(count, 0);
}

// ** Test getUptime() **
TEST(SystemStatsTest, GetUptimeReturnsValidTime) {
    long uptime = getUptime();
    ASSERT_GT(uptime, 0);
}

// ** Test loadConfig() **
TEST(SystemStatsTest, LoadConfigUpdatesLoggingInterval) {
    std::ofstream configFile("../config.xml");
    configFile << "<config><logging_interval>5</logging_interval></config>";
    configFile.close();

    loadConfig();
    ASSERT_EQ(logging_interval, 5);
}

// ** Test broadcastStats() **
TEST(SystemStatsTest, BroadcastStatsRunsWithoutCrash) {
    logging_interval = 1;
    boot_count.store(5);

    std::thread broadcastThread(broadcastStats);
    std::this_thread::sleep_for(std::chrono::seconds(2)); 
    broadcastThread.detach();
}

// ** Test handleClient() Initialization **
TEST(SystemStatsTest, HandleClientInitializesWithoutCrash) {
    boost::asio::io_context ioc;
    boost::asio::ip::tcp::socket socket(ioc);

    std::thread clientThread([&]() {
        handleClient(std::move(socket));
    });

    clientThread.detach();
}