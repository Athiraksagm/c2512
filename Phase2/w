#include "gtest/gtest.h"
#include "../include/server.h"
#include <boost/asio.hpp>
#include <boost/beast/websocket.hpp>
#include <thread>
#include <chrono>

using namespace boost::asio;
using namespace boost::beast;
using namespace boost::asio::ip;

// Function to simulate a WebSocket client connecting to the server
void simulateClient(std::string &received_message, bool &connection_status) {
    try {
        io_context ioc;
        tcp::resolver resolver(ioc);
        websocket::stream<tcp::socket> ws(ioc);

        auto const results = resolver.resolve("127.0.0.1", "8080");
        connect(ws.next_layer(), results.begin(), results.end());
        ws.handshake("127.0.0.1", "/");

        // Send initial request
        ws.write(net::buffer(std::string("REQUEST_STATS")));

        // Read server response
        flat_buffer buffer;
        ws.read(buffer);
        received_message = buffers_to_string(buffer.data());
        connection_status = true;

        ws.close(websocket::close_code::normal);
    } catch (...) {
        connection_status = false;
    }
}

// Test case for handling client connection
TEST(ServerTests, HandleClient) {
    io_context ioc;
    tcp::acceptor acceptor(ioc, tcp::endpoint(tcp::v4(), 8080));

    // Start a server thread that accepts one client
    std::thread server_thread([&]() {
        tcp::socket socket(ioc);
        acceptor.accept(socket);
        handleClient(std::move(socket));
    });

    std::this_thread::sleep_for(std::chrono::seconds(1)); // Wait for the server to start

    std::string received_message;
    bool connection_status = false;
    simulateClient(received_message, connection_status);

    EXPECT_TRUE(connection_status);
    EXPECT_FALSE(received_message.empty());

    server_thread.join();
}