#include "gtest/gtest.h"
#include "../include/server.h"
#include <fstream>

using json = nlohmann::json;
using namespace boost::asio;
using namespace boost::beast;
using namespace boost::asio::ip;
using namespace tinyxml2;

// Global variables from server.cpp
std::atomic<int> boot_count(0);
int logging_interval = 10; 

//Mocked function for getBootCount()
int mock_getBootCount(std::string command_output = "5\n") {
    try {
        return std::stoi(command_output);
    } catch (...) {
        return -1;  // Simulate error case
    }
}

//Mocked function for getUptime()
long getMockedUptime() {
    return 3600;  // Returns a predefined uptime (1 hour)
}

//Mock function for loading config
void mock_loadConfig(const std::string &filename) {
    XMLDocument doc;
    if (doc.LoadFile(filename.c_str()) != XML_SUCCESS) {
        return;
    }
    XMLElement *root = doc.FirstChildElement("config");
    if (root) {
        XMLElement *intervalElement = root->FirstChildElement("logging_interval");
        if (intervalElement) {
            logging_interval = std::stoi(intervalElement->GetText());
        }
    }
}

//TEST 1: Boot count retrieval (Normal Case)
TEST(SystemStatsTest, BootCountRetrieval) {
    boot_count.store(mock_getBootCount("5\n"));
    EXPECT_EQ(boot_count.load(), 5);
}

//TEST 2: Boot count retrieval (Error Case)
TEST(SystemStatsTest, BootCountRetrievalError) {
    boot_count.store(mock_getBootCount("invalid_data\n"));
    EXPECT_EQ(boot_count.load(), -1);
}

//TEST 3: Uptime retrieval (Normal Case)
TEST(SystemStatsTest, UptimeRetrieval) {
    EXPECT_EQ(getMockedUptime(), 3600);
}

//TEST 4: Config Loading (Logging Interval)
TEST(SystemStatsTest, LoadConfig) {
    std::ofstream configFile("mock_config.xml");
    configFile << "<config><logging_interval>15</logging_interval></config>";
    configFile.close();

    logging_interval = 10;  // Reset before test
    mock_loadConfig("mock_config.xml");
    EXPECT_EQ(logging_interval, 15);
}

//TEST 5: JSON Response Format
TEST(SystemStatsTest, JsonResponseFormat) {
    json response_json;
    boot_count.store(5);
    response_json["boot_count"] = boot_count.load();
    response_json["uptime"] = getMockedUptime();

    EXPECT_EQ(response_json.dump(), R"({"boot_count":5,"uptime":3600})");
}

//TEST 6: BroadcastStats Runs Without Crash
TEST(SystemStatsTest, BroadcastStatsRuns) {
    EXPECT_NO_THROW({
        std::thread broadcastThread([]() {
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
        });
        broadcastThread.join();
    });
}

//MAIN FUNCTION
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
